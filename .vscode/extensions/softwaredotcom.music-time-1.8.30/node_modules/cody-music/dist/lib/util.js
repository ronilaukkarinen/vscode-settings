"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const models_1 = require("./models");
const cp = require("child_process");
class MusicUtil {
    isLinux() {
        return this.isWindows() || this.isMac() ? false : true;
    }
    // process.platform return the following...
    //   -> 'darwin', 'freebsd', 'linux', 'sunos' or 'win32'
    isWindows() {
        return process.platform.indexOf("win32") !== -1;
    }
    isMac() {
        return process.platform.indexOf("darwin") !== -1;
    }
    isEmptyObj(obj) {
        return Object.keys(obj).length === 0 && obj.constructor === Object;
    }
    isResponseOk(resp) {
        if (resp && resp.status === 200) {
            return true;
        }
        return false;
    }
    isItemsResponseOk(codyResp) {
        if (codyResp &&
            codyResp.status === 200 &&
            codyResp.data &&
            codyResp.data.items) {
            return true;
        }
        return false;
    }
    isResponseOkWithData(resp) {
        if (resp && resp.status === 200 && resp.data) {
            return true;
        }
        return false;
    }
    isBooleanString(val) {
        if ((val && val.toLowerCase() === "true") ||
            val.toLowerCase() === "false") {
            return true;
        }
        return false;
    }
    async execCmd(cmd, projectDir = null) {
        let result = null;
        try {
            let opts = projectDir !== undefined && projectDir !== null
                ? { cwd: projectDir }
                : {};
            result = await this.execPromise(cmd, opts);
        }
        catch (e) {
            result = { error: e.message };
        }
        return result;
    }
    async execPromise(command, opts) {
        return new Promise((resolve, reject) => {
            cp.exec(command, opts, (error, stdout, stderr) => {
                if (error) {
                    reject(error);
                    return;
                }
                resolve(stdout.trim());
            });
        });
    }
    // Sleep for the designated milliseconds.
    // It should not be used in lib but only in the test.
    // It has a max of 5 seconds as this is resource intensive
    sleep(delayInMillis) {
        delayInMillis = Math.min(delayInMillis, 5000);
        var start = new Date().getTime();
        while (new Date().getTime() < start + delayInMillis)
            ;
    }
    getPlayerName(player) {
        if (!player || player.trim().length === 0) {
            return models_1.PlayerName.SpotifyDesktop;
        }
        player = player.trim().toLowerCase();
        if (player === "itunes") {
            return models_1.PlayerName.ItunesDesktop;
        }
        else if (player === "spotify-web") {
            return models_1.PlayerName.SpotifyWeb;
        }
        return models_1.PlayerName.SpotifyDesktop;
    }
    formatString(source, params) {
        let formatted = source;
        if (params && params.length > 0) {
            for (let i = 0; i < params.length; i++) {
                let regexp = new RegExp("\\{" + i + "\\}", "gi");
                formatted = formatted.replace(regexp, params[i]);
            }
        }
        return formatted;
    }
    isTrackRunning(track) {
        if (!track || !track.id) {
            return false;
        }
        if (track.state === models_1.TrackStatus.Paused ||
            track.state === models_1.TrackStatus.Playing) {
            return true;
        }
        return false;
    }
    isTrackPlaying(track) {
        if (!track || !track.id) {
            return false;
        }
        if (track.state === models_1.TrackStatus.Playing) {
            return true;
        }
        return false;
    }
    createPlaylistUriFromPlaylistId(playlist_id) {
        if (!playlist_id.includes("spotify:playlist:")) {
            playlist_id = `spotify:playlist:${playlist_id}`;
        }
        return playlist_id;
    }
    createTrackIdsFromUris(uris) {
        let trackIds = [];
        for (let i = 0; i < uris.length; i++) {
            trackIds.push(this.createSpotifyIdFromUri(uris[i]));
        }
        return trackIds;
    }
    createUriFromTrackId(track_id) {
        if (track_id && !track_id.includes("spotify:track:")) {
            track_id = `spotify:track:${track_id}`;
        }
        return track_id;
    }
    createUrisFromTrackIds(track_ids, useUriObj = false) {
        let tracks = [];
        for (let i = 0; i < track_ids.length; i++) {
            let uri = track_ids[i];
            if (!uri || uri.length === 0) {
                continue;
            }
            uri = this.createUriFromTrackId(uri);
            if (useUriObj) {
                const urlObj = {
                    uri
                };
                tracks.push(urlObj);
            }
            else {
                tracks.push(uri);
            }
        }
        return tracks;
    }
    createSpotifyUserUriFromId(id) {
        if (id && !id.includes("spotify:user:")) {
            id = `spotify:user:${id}`;
        }
        return id;
    }
    createSpotifyIdFromUri(uri) {
        if (uri && uri.indexOf("spotify:") === 0) {
            return uri.substring(uri.lastIndexOf(":") + 1);
        }
        return uri;
    }
    createSpotifyIdsFromUris(uris) {
        const ids = [];
        if (uris && uris.length) {
            uris.forEach(uri => {
                ids.push(this.createSpotifyIdFromUri(uri));
            });
        }
        return ids;
    }
    extractAristFromSpotifyTrack(track) {
        if (!track) {
            return;
        }
        if (track["artists"]) {
            const len = track["artists"].length;
            let artistNames = [];
            let artists = [];
            for (let y = 0; y < len; y++) {
                const artist = track["artists"][y];
                artistNames.push(artist.name);
                artists.push({
                    name: artist.name,
                    uri: artist.uri,
                    id: artist.id
                });
            }
            delete track.artists;
            track.artists = artists;
            track["artist"] = artistNames.join(", ");
            track["artist_names"] = artistNames;
        }
    }
    launchWebUrl(url) {
        let open = "open";
        let args = [url];
        if (this.isWindows()) {
            open = "cmd";
            // adds the following args to the beginning of the array
            args.unshift("/c", "start", '""');
        }
        else if (!this.isMac()) {
            open = "xdg-open";
        }
        args.unshift(open);
        const cmd = args.join(" ");
        return this.execCmd(cmd);
    }
    copySpotifyTrackToCodyTrack(spotifyTrack) {
        let track;
        if (spotifyTrack) {
            // delete some attributes that are currently not needed
            if (spotifyTrack.album) {
                delete spotifyTrack.album.available_markets;
                delete spotifyTrack.album.external_urls;
            }
            if (spotifyTrack.external_urls) {
                delete spotifyTrack.external_urls;
            }
            if (spotifyTrack.external_ids) {
                delete spotifyTrack.external_ids;
            }
            // pull out the artist info into a more readable set of attributes
            this.extractAristFromSpotifyTrack(spotifyTrack);
            track = spotifyTrack;
            if (spotifyTrack.duration_ms) {
                track.duration = spotifyTrack.duration_ms;
            }
        }
        else {
            track = new models_1.Track();
        }
        track.type = "spotify";
        track.playerType = models_1.PlayerType.WebSpotify;
        return track;
    }
    buildQueryString(obj, encodeVals = true) {
        let params = [];
        if (obj) {
            let keys = Object.keys(obj);
            if (keys) {
                for (let i = 0; i < keys.length; i++) {
                    let key = keys[i];
                    let val = obj[key];
                    if (val && val !== undefined) {
                        if (encodeVals) {
                            let encodedVal = encodeURIComponent(val);
                            params.push(`${key}=${encodedVal}`);
                        }
                        else {
                            params.push(`${key}=${val}`);
                        }
                    }
                }
            }
        }
        if (params.length > 0) {
            return "?" + params.join("&");
        }
        else {
            return "";
        }
    }
}
exports.MusicUtil = MusicUtil;
