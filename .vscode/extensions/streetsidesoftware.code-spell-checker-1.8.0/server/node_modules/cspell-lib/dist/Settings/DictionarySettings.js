"use strict";
var __rest = (this && this.__rest) || function (s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                t[p[i]] = s[p[i]];
        }
    return t;
};
Object.defineProperty(exports, "__esModule", { value: true });
const path = require("path");
const os = require("os");
const dictionaryPath = () => path.join(__dirname, '..', '..', 'dist', 'dictionaries');
function filterDictDefsToLoad(dictIds, defs) {
    // Process the dictIds in order, if it starts with a '!', remove it from the set.
    const dictIdSet = dictIds
        .map(id => id.trim())
        .filter(id => !!id)
        .reduce((dictSet, id) => {
        if (id[0] === '!') {
            dictSet.delete(id.slice(1));
        }
        else {
            dictSet.add(id);
        }
        return dictSet;
    }, new Set());
    const activeDefs = defs
        .filter(({ name }) => dictIdSet.has(name))
        .map(def => (Object.assign(Object.assign({}, def), { path: getFullPathName(def) })))
        // Remove any empty paths.
        .filter(def => !!def.path)
        .map(def => [def.name, def]);
    return [...(new Map(activeDefs))];
}
exports.filterDictDefsToLoad = filterDictDefsToLoad;
function getFullPathName(def) {
    const { path: filePath = '', file = '' } = def;
    if (!filePath && !file) {
        return '';
    }
    const dictPath = path.join(filePath || dictionaryPath(), file);
    return path.resolve(dictPath);
}
function normalizePathForDictDefs(defs, defaultPath) {
    return defs
        .map(def => normalizePathForDictDef(def, defaultPath));
}
exports.normalizePathForDictDefs = normalizePathForDictDefs;
function normalizePathForDictDef(def, defaultPath) {
    const { path: relPath = '.', file } = def, rest = __rest(def, ["path", "file"]);
    const nonRelPath = relPath.match(/^\./) ? path.join(defaultPath, relPath) : relPath;
    const absPath = nonRelPath.replace(/^~/, os.homedir());
    const fullPath = file ? path.join(absPath, file) : absPath;
    return Object.assign(Object.assign({}, rest), { path: fullPath });
}
exports.normalizePathForDictDef = normalizePathForDictDef;
//# sourceMappingURL=DictionarySettings.js.map