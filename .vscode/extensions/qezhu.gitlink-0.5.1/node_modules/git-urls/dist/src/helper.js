"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const fs = require("fs-extra");
const path = require("path");
const configInfo_1 = require("./configInfo");
class Helper {
    static parseConfigAsync(repoRoot) {
        return __awaiter(this, void 0, void 0, function* () {
            const configPath = path.join(repoRoot, ".git/config");
            const headPath = path.join(repoRoot, ".git/HEAD");
            const existConfig = yield fs.pathExists(configPath);
            const existHead = yield fs.pathExists(headPath);
            if (!existConfig || !existHead) {
                throw new Error(`No git config files found in ${repoRoot}.`);
            }
            const configContent = yield fs.readFile(configPath, "utf8");
            const headContent = yield fs.readFile(headPath, "utf8");
            const remoteMap = this.parseRemoteUrl(configContent);
            const branch = this.parseBranchName(headContent);
            if (!remoteMap) {
                throw new Error(`Can't get remote name/url from ${configPath}.`);
            }
            if (!branch) {
                throw new Error(`Can't get branch name from ${headPath}.`);
            }
            var configMap = new Map();
            for (let [key, value] of remoteMap) {
                configMap.set(key, new configInfo_1.default(value, branch));
            }
            return configMap;
        });
    }
    static getRepoRoot(filePath) {
        let currentFolder = this.normarlize(path.dirname(filePath));
        while (true) {
            const configFolder = path.join(currentFolder, ".git");
            if (fs.existsSync(configFolder)) {
                return currentFolder;
            }
            let index = currentFolder.lastIndexOf('/');
            if (index < 0) {
                break;
            }
            currentFolder = currentFolder.substring(0, index);
        }
        return null;
    }
    static normarlize(filePath) {
        return filePath.replace(/\\/g, '/');
    }
    static parseRemoteUrl(content) {
        const regex = /\n\[remote \"(.+)\"\]\s+url\s*=\s*(.+)\n/gi;
        let result = new Map();
        let matches = regex.exec(content);
        while (matches !== null) {
            if (matches.index === regex.lastIndex) {
                regex.lastIndex++;
            }
            result.set(matches[1], matches[2]);
            matches = regex.exec(content);
        }
        if (result.size > 0) {
            return result;
        }
        return null;
    }
    static parseBranchName(content) {
        const regex = /ref:\s+refs\/heads\/(\S+)/;
        const matches = regex.exec(content);
        if (!matches) {
            return null;
        }
        return matches[1];
    }
}
exports.default = Helper;
//# sourceMappingURL=helper.js.map