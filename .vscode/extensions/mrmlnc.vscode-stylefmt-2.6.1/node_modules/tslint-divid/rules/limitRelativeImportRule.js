"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var ts = require("typescript");
var Lint = require("tslint");
var path = require("path");
var Rule = /** @class */ (function (_super) {
    __extends(Rule, _super);
    function Rule(options) {
        var _this = _super.call(this, options) || this;
        _this.containment = "./";
        var containmentRelative = options.ruleArguments[0];
        if (!containmentRelative) {
            throw new Error("Missing relative containment path");
        }
        _this.containment = path.resolve(containmentRelative);
        return _this;
    }
    Rule.prototype.apply = function (sourceFile) {
        var sourceFileName = sourceFile.fileName;
        var absoulutFileName = path.isAbsolute(sourceFileName)
            ? sourceFileName
            : path.resolve(sourceFileName);
        var sourceFileDirectory = getDirectoryNameFromFullFileNamePath(absoulutFileName);
        if (!isInside(this.containment, sourceFileDirectory)) {
            return [];
        }
        var maxLevels = path.relative(sourceFileDirectory, this.containment).split("..").length -
            1;
        return this.applyWithFunction(sourceFile, function (ctx) {
            checkNode(ctx, maxLevels);
        });
    };
    Rule.FAILURE_STRING = "Import violating limit-relative-import rule";
    return Rule;
}(Lint.Rules.AbstractRule));
exports.Rule = Rule;
function checkNode(ctx, maxLevels) {
    return ts.forEachChild(ctx.sourceFile, cb);
    function cb(node) {
        if (node.kind !== ts.SyntaxKind.ImportDeclaration) {
            return;
        }
        var importDeclaration = node;
        var importText = importDeclaration.moduleSpecifier
            .getText()
            .replace(/^"(.+?)"$/, "$1");
        if (!importText.startsWith("../")) {
            return;
        }
        var levels = countLevels(importText);
        // console.log("levels", levels);
        if (levels >= maxLevels) {
            ctx.addFailureAtNode(importDeclaration.moduleSpecifier, Rule.FAILURE_STRING);
        }
    }
}
function getDirectoryNameFromFullFileNamePath(fileNamePath) {
    return fileNamePath.replace(/(.*?\/)[^\/]+?$/, "$1");
}
function isInside(containment, fileName) {
    return fileName.replace(containment, "").length < fileName.length;
}
function countLevels(importText) {
    // console.log("importText", importText);
    return importText.split("/").reduce(function (soFar, current) {
        // console.log("current", current);
        switch (current) {
            case "..":
                return soFar + 1;
            default:
                return soFar;
        }
    }, 0);
}
