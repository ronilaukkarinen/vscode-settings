"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const ajv_1 = __importDefault(require("ajv"));
const better_ajv_errors_1 = __importDefault(require("better-ajv-errors"));
const deepmerge_1 = __importDefault(require("deepmerge"));
const json_merge_patch_1 = __importDefault(require("json-merge-patch"));
const user_error_1 = require("../error/user-error");
const validation_error_1 = require("./validation-error");
const dynamicKeys = [
    "metadata",
    "flow",
    "sectioning",
    "heading",
    "phrasing",
    "embedded",
    "interactive",
];
const functionTable = {
    isDescendant,
    hasAttribute,
    matchAttribute,
};
function clone(src) {
    return JSON.parse(JSON.stringify(src));
}
class MetaTable {
    constructor() {
        this.elements = {};
        this.schema = clone(require("../../elements/schema.json"));
    }
    init() {
        this.resolveGlobal();
    }
    /**
     * Extend validation schema.
     */
    extendValidationSchema(patch) {
        if (patch.properties) {
            this.schema = json_merge_patch_1.default.apply(this.schema, {
                patternProperties: {
                    "^.*$": {
                        properties: patch.properties,
                    },
                },
            });
        }
        if (patch.definitions) {
            this.schema = json_merge_patch_1.default.apply(this.schema, {
                definitions: patch.definitions,
            });
        }
    }
    /**
     * Load metadata table from object.
     */
    loadFromObject(obj) {
        const ajv = new ajv_1.default({ jsonPointers: true });
        const validator = ajv.compile(this.schema);
        const valid = validator(obj);
        if (!valid) {
            const output = better_ajv_errors_1.default(this.schema, obj, validator.errors, {
                format: "js",
            });
            const message = output[0].error;
            throw new validation_error_1.MetaValidationError(`Element metadata is not valid: ${message}`, obj, this.schema, validator.errors);
        }
        for (const key of Object.keys(obj)) {
            this.addEntry(key, obj[key]);
        }
    }
    /**
     * Load metadata table from filename
     */
    loadFromFile(filename) {
        let json;
        try {
            json = require(filename);
        }
        catch (err) {
            throw new user_error_1.UserError(`Failed to load element metadata from "${filename}"`, err);
        }
        this.loadFromObject(clone(json));
    }
    getMetaFor(tagName) {
        /* @TODO Only entries with dynamic properties has to be copied, static
         * entries could be shared */
        tagName = tagName.toLowerCase();
        return this.elements[tagName]
            ? Object.assign({}, this.elements[tagName])
            : null;
    }
    addEntry(tagName, entry) {
        const expanded = Object.assign({
            tagName,
            void: false,
        }, entry);
        expandRegex(expanded);
        this.elements[tagName] = expanded;
    }
    /**
     * Finds the global element definition and merges each known element with the
     * global, e.g. to assign global attributes.
     */
    resolveGlobal() {
        /* skip if there is no global elements */
        if (!this.elements["*"])
            return;
        /* fetch and remove the global element, it should not be resolvable by
         * itself */
        const global = this.elements["*"];
        delete this.elements["*"];
        /* hack: unset default properties which global should not override */
        delete global.tagName;
        delete global.void;
        /* merge elements */
        for (const [tagName, entry] of Object.entries(this.elements)) {
            this.elements[tagName] = this.mergeElement(entry, global);
        }
    }
    mergeElement(a, b) {
        return deepmerge_1.default(a, b);
    }
    resolve(node) {
        if (node.meta) {
            expandProperties(node, node.meta);
        }
    }
}
exports.MetaTable = MetaTable;
function expandProperties(node, entry) {
    for (const key of dynamicKeys) {
        const property = entry[key];
        if (property && typeof property !== "boolean") {
            entry[key] = evaluateProperty(node, property);
        }
    }
}
function expandRegex(entry) {
    if (!entry.attributes)
        return;
    for (const [name, values] of Object.entries(entry.attributes)) {
        entry.attributes[name] = values.map((value) => {
            const match = typeof value === "string" && value.match(/^\/(.*)\/$/);
            if (match) {
                return new RegExp(match[1]);
            }
            else {
                return value;
            }
        });
    }
}
function evaluateProperty(node, expr) {
    const [func, options] = parseExpression(expr);
    return func(node, options);
}
function parseExpression(expr) {
    if (typeof expr === "string") {
        return parseExpression([expr, {}]);
    }
    else {
        const [funcName, options] = expr;
        const func = functionTable[funcName];
        if (!func) {
            throw new Error(`Failed to find function "${funcName}" when evaluating property expression`);
        }
        return [func, options];
    }
}
function isDescendant(node, tagName) {
    if (typeof tagName !== "string") {
        throw new Error(`Property expression "isDescendant" must take string argument when evaluating metadata for <${node.tagName}>`);
    }
    let cur = node.parent;
    while (!cur.isRootElement()) {
        if (cur.is(tagName)) {
            return true;
        }
        cur = cur.parent;
    }
    return false;
}
function hasAttribute(node, attr) {
    if (typeof attr !== "string") {
        throw new Error(`Property expression "hasAttribute" must take string argument when evaluating metadata for <${node.tagName}>`);
    }
    return node.hasAttribute(attr);
}
function matchAttribute(node, match) {
    if (!Array.isArray(match) || match.length !== 3) {
        throw new Error(`Property expression "matchAttribute" must take [key, op, value] array as argument when evaluating metadata for <${node.tagName}>`);
    }
    const [key, op, value] = match.map(x => x.toLowerCase());
    const nodeValue = (node.getAttributeValue(key) || "").toLowerCase();
    switch (op) {
        case "!=":
            return nodeValue !== value;
        case "=":
            return nodeValue === value;
        default:
            throw new Error(`Property expression "matchAttribute" has invalid operator "${op}" when evaluating metadata for <${node.tagName}>`);
    }
}
