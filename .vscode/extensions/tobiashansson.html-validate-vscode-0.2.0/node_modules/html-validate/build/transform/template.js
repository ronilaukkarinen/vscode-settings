"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const fs_1 = __importDefault(require("fs"));
const espree = require("espree");
const walk = require("acorn-walk");
function joinTemplateLiteral(nodes) {
    let offset = nodes[0].start;
    let output = "";
    for (const node of nodes) {
        output += " ".repeat(node.start - offset);
        output += node.value.raw;
        offset = node.end;
    }
    return output;
}
function extractLiteral(node, filename) {
    switch (node.type) {
        /* ignored nodes */
        case "FunctionExpression":
            return null;
        case "Literal":
            return {
                data: node.value.toString(),
                filename: null,
                line: node.loc.start.line,
                column: node.loc.start.column + 1,
            };
        case "TemplateLiteral":
            return {
                data: joinTemplateLiteral(node.quasis),
                filename: null,
                line: node.loc.start.line,
                column: node.loc.start.column + 1,
            };
        case "TaggedTemplateExpression":
            return {
                data: joinTemplateLiteral(node.quasi.quasis),
                filename: null,
                line: node.quasi.loc.start.line,
                column: node.quasi.loc.start.column + 1,
            };
        case "ArrowFunctionExpression": {
            const whitelist = ["Literal", "TemplateLiteral"];
            if (whitelist.includes(node.body.type)) {
                return extractLiteral(node.body, filename);
            }
            else {
                return null;
            }
        }
        /* istanbul ignore next: this only provides a better error, all currently known nodes are tested */
        default: {
            const loc = node.loc.start;
            const context = `${filename}:${loc.line}:${loc.column}`;
            throw Error(`Unhandled node type "${node.type}" at "${context}" in extractLiteral`);
        }
    }
}
function compareKey(node, key, filename) {
    switch (node.type) {
        case "Identifier":
            return node.name === key;
        case "Literal":
            return node.value === key;
        /* istanbul ignore next: this only provides a better error, all currently known nodes are tested */
        default: {
            const loc = node.loc.start;
            const context = `${filename}:${loc.line}:${loc.column}`;
            throw Error(`Unhandled node type "${node.type}" at "${context}" in compareKey`);
        }
    }
}
class TemplateExtractor {
    constructor(ast, filename) {
        this.ast = ast;
        this.filename = filename;
    }
    static fromFilename(filename) {
        const source = fs_1.default.readFileSync(filename);
        const ast = espree.parse(source, {
            ecmaVersion: 2017,
            sourceType: "module",
            loc: true,
        });
        return new TemplateExtractor(ast, filename);
    }
    /**
     * Create a new [[TemplateExtractor]] from javascript source code.
     *
     * `Source` offsets will be relative to the string, i.e. offset 0 is the first
     * character of the string. If the string is only a subset of a larger string
     * the offsets must be adjusted manually.
     *
     * @param source - Source code.
     * @param filename - Optional filename to set in the resulting
     * `Source`. Defauls to `"inline"`.
     */
    static fromString(source, filename) {
        const ast = espree.parse(source, {
            ecmaVersion: 2017,
            sourceType: "module",
            loc: true,
        });
        return new TemplateExtractor(ast, filename || "inline");
    }
    /**
     * Convenience function to create a [[Source]] instance from an existing file.
     *
     * @param filename - Filename with javascript source code. The file must exist
     * and be readable by the user.
     * @returns An array of Source's suitable for passing to [[Engine]] linting
     * functions.
     */
    static createSource(filename) {
        const data = fs_1.default.readFileSync(filename, "utf-8");
        return [
            {
                column: 1,
                data,
                filename,
                line: 1,
            },
        ];
    }
    /**
     * Extract object properties.
     *
     * Given a key `"template"` this method finds all objects literals with a
     * `"template"` property and creates a [[Source]] instance with proper offsets
     * with the value of the property. For instance:
     *
     * ```
     * const myObj = {
     *   foo: 'bar',
     * };
     * ```
     *
     * The above snippet would yield a `Source` with the content `bar`.
     *
     */
    extractObjectProperty(key) {
        const result = [];
        const filename = this.filename;
        walk.simple(this.ast, {
            Property(node) {
                if (compareKey(node.key, key, filename)) {
                    const source = extractLiteral(node.value, filename);
                    if (source) {
                        source.filename = filename;
                        result.push(source);
                    }
                }
            },
        });
        return result;
    }
}
exports.TemplateExtractor = TemplateExtractor;
