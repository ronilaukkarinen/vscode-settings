"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const deepmerge_1 = __importDefault(require("deepmerge"));
const fs_1 = __importDefault(require("fs"));
const path_1 = __importDefault(require("path"));
const nested_error_1 = require("../error/nested-error");
const user_error_1 = require("../error/user-error");
const meta_1 = require("../meta");
const default_1 = __importDefault(require("./default"));
const severity_1 = require("./severity");
const recommended = require("./recommended");
const document = require("./document");
let rootDirCache = null;
function overwriteMerge(a, b) {
    return b;
}
function mergeInternal(base, rhs) {
    const dst = deepmerge_1.default(base, Object.assign({}, rhs, { rules: {} }));
    /* rules need some special care, should overwrite arrays instead of
     * concaternation, i.e. ["error", {...options}] should not be merged by
     * appending to old value */
    if (rhs.rules) {
        dst.rules = deepmerge_1.default(dst.rules, rhs.rules, { arrayMerge: overwriteMerge });
    }
    return dst;
}
function loadFromFile(filename) {
    let json;
    try {
        json = require(filename);
    }
    catch (err) {
        throw new user_error_1.UserError(`Failed to read configuration from "${filename}"`, err);
    }
    /* expand any relative paths */
    for (const key of ["extends", "elements", "plugins"]) {
        if (!json[key])
            continue;
        json[key] = json[key].map((ref) => {
            return Config.expandRelative(ref, path_1.default.dirname(filename));
        });
    }
    return json;
}
/**
 * Configuration holder.
 *
 * Each file being validated will have a unique instance of this class.
 */
class Config {
    /**
     * Create a new blank configuration. See also `Config.defaultConfig()`.
     */
    static empty() {
        return new Config({
            extends: [],
            rules: {},
            plugins: [],
            transform: {},
        });
    }
    /**
     * Create configuration from object.
     */
    static fromObject(options) {
        return new Config(options);
    }
    /**
     * Read configuration from filename.
     *
     * Note: this reads configuration data from a file. If you intent to load
     * configuration for a file to validate use `ConfigLoader.fromTarget()`.
     *
     * @param filename - The file to read from or one of the presets such as
     * `htmlvalidate:recommended`.
     */
    static fromFile(filename) {
        const configdata = loadFromFile(filename);
        return new Config(configdata);
    }
    /**
     * Load a default configuration object.
     */
    static defaultConfig() {
        return new Config(default_1.default);
    }
    constructor(options) {
        const initial = {
            extends: [],
            plugins: [],
            rules: {},
            transform: {},
        };
        this.config = mergeInternal(initial, options || {});
        this.metaTable = null;
        this.rootDir = this.findRootDir();
        /* load plugins */
        this.plugins = this.loadPlugins(this.config.plugins || []);
        this.configurations = this.loadConfigurations(this.plugins);
        /* process extended configs */
        for (const extend of this.config.extends) {
            this.config = this.extendConfig(extend);
        }
        /* rules explicitly set by passed options should have precedence over any
         * extended rules, not the other way around. */
        if (options && options.rules) {
            this.config = mergeInternal(this.config, { rules: options.rules });
        }
    }
    /**
     * Initialize plugins, transforms etc.
     *
     * Must be called before trying to use config.
     */
    init() {
        /* precompile transform patterns */
        this.transformers = this.precompileTransformers(this.config.transform || {});
    }
    /**
     * Returns a new configuration as a merge of the two. Entries from the passed
     * object takes priority over this object.
     *
     * @param {Config} rhs - Configuration to merge with this one.
     */
    merge(rhs) {
        return new Config(mergeInternal(this.config, rhs.config));
    }
    extendConfig(entry) {
        let base;
        if (this.configurations.has(entry)) {
            base = this.configurations.get(entry);
        }
        else {
            base = Config.fromFile(entry).config;
        }
        return mergeInternal(this.config, base);
    }
    /**
     * Get element metadata.
     */
    getMetaTable() {
        /* use cached table if it exists */
        if (this.metaTable) {
            return this.metaTable;
        }
        const metaTable = new meta_1.MetaTable();
        const source = this.config.elements || ["html5"];
        const root = path_1.default.resolve(__dirname, "..", "..");
        /* extend validation schema from plugins */
        for (const plugin of this.getPlugins()) {
            if (plugin.elementSchema) {
                metaTable.extendValidationSchema(plugin.elementSchema);
            }
        }
        /* load from all entries */
        for (const entry of source) {
            /* load meta directly from entry */
            if (typeof entry !== "string") {
                metaTable.loadFromObject(entry);
                continue;
            }
            /* try searching builtin metadata */
            const filename = `${root}/elements/${entry}.json`;
            if (fs_1.default.existsSync(filename)) {
                metaTable.loadFromFile(filename);
                continue;
            }
            /* try as regular file */
            if (fs_1.default.existsSync(entry)) {
                metaTable.loadFromFile(entry);
                continue;
            }
            /* assume it is loadable with require() */
            metaTable.loadFromObject(require(entry));
        }
        metaTable.init();
        return (this.metaTable = metaTable);
    }
    /**
     * @hidden exposed for testing only
     */
    static expandRelative(src, currentPath) {
        if (src[0] === ".") {
            return path_1.default.normalize(`${currentPath}/${src}`);
        }
        return src;
    }
    /**
     * Get a copy of internal configuration data.
     *
     * @hidden primary purpose is unittests
     */
    get() {
        const config = Object.assign({}, this.config);
        if (config.elements) {
            config.elements = config.elements.map((cur) => cur.replace(this.rootDir, "<rootDir>"));
        }
        return config;
    }
    /**
     * Get all configured rules, their severity and options.
     */
    getRules() {
        const rules = new Map();
        for (const [ruleId, data] of Object.entries(this.config.rules)) {
            let options = data;
            if (!Array.isArray(options)) {
                options = [options, {}];
            }
            else if (options.length === 1) {
                options = [options[0], {}];
            }
            const severity = severity_1.parseSeverity(options[0]);
            rules.set(ruleId, [severity, options[1]]);
        }
        return rules;
    }
    /**
     * Get all configured plugins.
     */
    getPlugins() {
        return this.plugins;
    }
    loadPlugins(plugins) {
        return plugins.map((moduleName) => {
            const plugin = require(moduleName.replace("<rootDir>", this.rootDir));
            plugin.name = moduleName;
            return plugin;
        });
    }
    loadConfigurations(plugins) {
        const configs = new Map();
        /* builtin presets */
        configs.set("htmlvalidate:recommended", recommended);
        configs.set("htmlvalidate:document", document);
        /* presets from plugins */
        for (const plugin of plugins) {
            for (const [name, config] of Object.entries(plugin.configs || {})) {
                configs.set(`${plugin.name}:${name}`, new Config(config).config);
            }
        }
        return configs;
    }
    /**
     * Transform a source file.
     *
     * @param filename - Filename to transform (according to configured
     * transformations)
     * @return A list of extracted sources ready for validation.
     */
    transform(filename) {
        const transformer = this.findTransformer(filename);
        if (transformer) {
            try {
                return transformer.fn(filename);
            }
            catch (err) {
                throw new nested_error_1.NestedError(`When transforming "${filename}": ${err.message}`, err);
            }
        }
        else {
            const data = fs_1.default.readFileSync(filename, { encoding: "utf8" });
            return [
                {
                    data,
                    filename,
                    line: 1,
                    column: 1,
                    originalData: data,
                },
            ];
        }
    }
    findTransformer(filename) {
        return this.transformers.find((entry) => entry.pattern.test(filename));
    }
    precompileTransformers(transform) {
        return Object.entries(transform).map(([pattern, module]) => {
            return {
                pattern: new RegExp(pattern),
                fn: require(module.replace("<rootDir>", this.rootDir)),
            };
        });
    }
    findRootDir() {
        if (rootDirCache !== null) {
            return rootDirCache;
        }
        /* try to locate package.json */
        let current = process.cwd();
        for (;;) {
            const search = path_1.default.join(current, "package.json");
            if (fs_1.default.existsSync(search)) {
                return (rootDirCache = current);
            }
            /* get the parent directory */
            const child = current;
            current = path_1.default.dirname(current);
            /* stop if this is the root directory */
            if (current === child) {
                break;
            }
        }
        /* default to working directory if no package.json is found */
        return (rootDirCache = process.cwd());
    }
}
exports.Config = Config;
