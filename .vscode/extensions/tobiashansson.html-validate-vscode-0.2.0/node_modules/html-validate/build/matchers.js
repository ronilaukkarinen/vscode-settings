"use strict";
/* eslint-disable @typescript-eslint/no-namespace, prefer-template */
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const jest_diff_1 = __importDefault(require("jest-diff"));
const lexer_1 = require("./lexer");
function toBeValid(report) {
    if (report.valid) {
        return {
            pass: true,
            message: () => "Result should not contain error",
        };
    }
    else {
        const firstError = report.results[0].messages[0];
        return {
            pass: false,
            message: () => `Result should be successful but had error "${firstError.message}"`,
        };
    }
}
function toBeInvalid(report) {
    if (report.valid) {
        return {
            pass: false,
            message: () => "Result should be successful",
        };
    }
    else {
        return {
            pass: true,
            message: () => "Result should not contain error",
        };
    }
}
function toHaveError(report, ruleId, message) {
    const actual = report.results.reduce((aggregated, result) => {
        return aggregated.concat(result.messages);
    }, []);
    const matcher = [expect.objectContaining({ ruleId, message })];
    const pass = this.equals(actual, matcher);
    const diffString = jest_diff_1.default(matcher, actual, { expand: this.expand });
    const resultMessage = () => this.utils.matcherHint(".toHaveError") +
        "\n\n" +
        "Expected token to equal:\n" +
        `  ${this.utils.printExpected(matcher)}\n` +
        "Received:\n" +
        `  ${this.utils.printReceived(actual)}` +
        (diffString ? `\n\nDifference:\n\n${diffString}` : "");
    return { pass, message: resultMessage };
}
function toHaveErrors(report, errors) {
    const actual = report.results.reduce((aggregated, result) => {
        return aggregated.concat(result.messages);
    }, []);
    const matcher = errors.map(entry => {
        if (Array.isArray(entry)) {
            const [ruleId, message] = entry;
            return expect.objectContaining({ ruleId, message });
        }
        else {
            return expect.objectContaining(entry);
        }
    });
    const pass = this.equals(actual, matcher);
    const diffString = jest_diff_1.default(matcher, actual, { expand: this.expand });
    const resultMessage = () => this.utils.matcherHint(".toHaveErrors") +
        "\n\n" +
        "Expected token to equal:\n" +
        `  ${this.utils.printExpected(matcher)}\n` +
        "Received:\n" +
        `  ${this.utils.printReceived(actual)}` +
        (diffString ? `\n\nDifference:\n\n${diffString}` : "");
    return { pass, message: resultMessage };
}
function toBeToken(actual, expected) {
    const token = actual.value;
    if (token.type) {
        token.type = lexer_1.TokenType[token.type];
    }
    if (expected.type) {
        expected.type = lexer_1.TokenType[expected.type];
    }
    const matcher = expect.objectContaining(expected);
    const pass = this.equals(token, matcher);
    const diffString = jest_diff_1.default(matcher, token, { expand: this.expand });
    const message = () => this.utils.matcherHint(".toBeToken") +
        "\n\n" +
        "Expected token to equal:\n" +
        `  ${this.utils.printExpected(matcher)}\n` +
        "Received:\n" +
        `  ${this.utils.printReceived(token)}` +
        (diffString ? `\n\nDifference:\n\n${diffString}` : "");
    return { pass, message };
}
expect.extend({
    toBeValid,
    toBeInvalid,
    toHaveError,
    toHaveErrors,
    toBeToken,
});
