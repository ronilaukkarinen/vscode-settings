"use strict";
var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (this && this.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
Object.defineProperty(exports, "__esModule", { value: true });
exports._findSortedJsonElement = exports._readJsonLinesSync = exports._readJsonArraySync = exports._getJsonValue = exports._setJsonValue = exports._appendJsonFileSync = exports._writeJsonFileSync = exports._writeContentFileSync = exports._writeJsonFileAsync = exports._writeContentFileAsync = exports._readJsonFileSync = exports._readContentFileSync = exports._readJsonFileAsync = exports._readContentFileAsync = exports._makeDirSync = void 0;
var util_1 = require("./util");
var fs = require("fs");
var universalify = require("universalify");
// this keeps a map of:
// fileName => jsonData
// in case reading ends of with a corrupted object
var contentMap = {};
function _makeDirSync(file) {
    return __awaiter(this, void 0, void 0, function () {
        return __generator(this, function (_a) {
            if (!fs.existsSync(file)) {
                fs.mkdirSync(file);
            }
            return [2 /*return*/];
        });
    });
}
exports._makeDirSync = _makeDirSync;
/**
 * Read a file asynchronously
 * @param file
 * @param options
 */
function _readContentFileAsync(file) {
    return __awaiter(this, void 0, void 0, function () {
        var content;
        return __generator(this, function (_a) {
            switch (_a.label) {
                case 0:
                    if (!fs.existsSync(file)) {
                        return [2 /*return*/, null];
                    }
                    return [4 /*yield*/, universalify.fromCallback(fs.readFile)(file, {
                            encoding: "utf8",
                        })];
                case 1:
                    content = _a.sent();
                    return [2 /*return*/, content];
            }
        });
    });
}
exports._readContentFileAsync = _readContentFileAsync;
/**
 * Read a file asynchronously
 * @param file
 * @param options
 */
function _readJsonFileAsync(file) {
    return __awaiter(this, void 0, void 0, function () {
        var content;
        return __generator(this, function (_a) {
            switch (_a.label) {
                case 0:
                    if (!fs.existsSync(file)) {
                        return [2 /*return*/, null];
                    }
                    return [4 /*yield*/, universalify.fromCallback(fs.readFile)(file, {
                            encoding: "utf8",
                        })];
                case 1:
                    content = _a.sent();
                    return [2 /*return*/, parseJsonContent(file, content)];
            }
        });
    });
}
exports._readJsonFileAsync = _readJsonFileAsync;
/**
 * parse and return (throw an err if exception is caught
 * @param file
 */
function _readContentFileSync(file) {
    if (!fs.existsSync(file)) {
        return null;
    }
    try {
        var content = fs.readFileSync(file, { encoding: "utf8" });
        return content;
    }
    catch (err) {
        var content = tryCachedContent(file, false);
        if (!content) {
            var message = "Error reading file content. " + file + " : " + err.message;
            return { error: err, message: message };
        }
        return content;
    }
}
exports._readContentFileSync = _readContentFileSync;
/**
 * Read a file synchronously
 * @param file
 * @param options
 */
function _readJsonFileSync(file) {
    if (!fs.existsSync(file)) {
        return null;
    }
    try {
        var content = fs.readFileSync(file, { encoding: "utf8" });
        return parseJsonContent(file, content);
    }
    catch (err) {
        var obj = tryCachedContent(file);
        if (!obj) {
            var message = "Error reading JSON content. " + file + " : " + err.message;
            return { error: err, message: message };
        }
        return obj;
    }
}
exports._readJsonFileSync = _readJsonFileSync;
function parseJsonContent(file, content) {
    // remove byte order mark
    content = util_1.cleanJsonString(content);
    var obj;
    try {
        obj = JSON.parse(content);
    }
    catch (err) {
        obj = tryCachedContent(file);
        if (!obj) {
            var message = "Error parsing JSON content. " + file + " : " + err.message;
            return { error: err, message: message };
        }
    }
    return obj;
}
function tryCachedContent(file, isJson) {
    if (isJson === void 0) { isJson = true; }
    var obj;
    var content = contentMap[file];
    if (content) {
        content = util_1.cleanJsonString(content);
        if (isJson) {
            try {
                obj = JSON.parse(content);
            }
            catch (err) {
                var message = "Error parsing cached JSON content. " + file + " : " + err.message;
                return { error: err, message: message };
            }
        }
        else {
            obj = content;
        }
    }
    // save the cached content
    _writeContentFileSync(file, content);
    return obj;
}
/**
 * Write a content file asynchronously
 */
function _writeContentFileAsync(file, content, options) {
    if (options === void 0) { options = {}; }
    return __awaiter(this, void 0, void 0, function () {
        var result;
        return __generator(this, function (_a) {
            switch (_a.label) {
                case 0:
                    if (!options.encoding) {
                        options = __assign(__assign({}, options), { encoding: "utf8" });
                    }
                    return [4 /*yield*/, universalify.fromCallback(fs.writeFile)(file, content, options)];
                case 1:
                    result = _a.sent();
                    return [4 /*yield*/, updateContentMap(file, content, options)];
                case 2:
                    _a.sent();
                    return [2 /*return*/, result];
            }
        });
    });
}
exports._writeContentFileAsync = _writeContentFileAsync;
/**
 * Write a json file asynchronously
 */
function _writeJsonFileAsync(file, obj, options) {
    if (options === void 0) { options = {}; }
    return __awaiter(this, void 0, void 0, function () {
        var content;
        return __generator(this, function (_a) {
            content = util_1.jsonStringify(obj, options);
            _writeContentFileAsync(file, content, options);
            return [2 /*return*/];
        });
    });
}
exports._writeJsonFileAsync = _writeJsonFileAsync;
/**
 * Write a content file synchronously
 */
function _writeContentFileSync(file, content, options) {
    if (options === void 0) { options = {}; }
    return __awaiter(this, void 0, void 0, function () {
        var obj, message, result;
        return __generator(this, function (_a) {
            switch (_a.label) {
                case 0:
                    if (!options.encoding) {
                        options = __assign(__assign({}, options), { encoding: "utf8" });
                    }
                    // check to see if the previous file is json
                    if (contentMap[file] && isJsonFileType(file)) {
                        try {
                            obj = JSON.parse(contentMap[file]);
                            if (obj) {
                                // the previous file is json, make sure we can parse this content to json
                                JSON.parse(content);
                            }
                        }
                        catch (err) {
                            message = "Error replacing existing JSON content with non-JSON content. " + file + " : " + err.message;
                            return [2 /*return*/, { error: err, message: message }];
                        }
                    }
                    result = fs.writeFileSync(file, content, options);
                    return [4 /*yield*/, updateContentMap(file, content, options)];
                case 1:
                    _a.sent();
                    return [2 /*return*/, result];
            }
        });
    });
}
exports._writeContentFileSync = _writeContentFileSync;
/**
 * Write a json file synchronously
 */
function _writeJsonFileSync(file, obj, options) {
    if (options === void 0) { options = {}; }
    var content = util_1.jsonStringify(obj, options);
    return _writeContentFileSync(file, content, options);
}
exports._writeJsonFileSync = _writeJsonFileSync;
function _appendJsonFileSync(file, obj, options) {
    if (options === void 0) { options = {}; }
    return __awaiter(this, void 0, void 0, function () {
        var content, result;
        return __generator(this, function (_a) {
            switch (_a.label) {
                case 0:
                    content = util_1.jsonStringify(obj, options);
                    if (!options.encoding) {
                        options = __assign(__assign({}, options), { encoding: "utf8" });
                    }
                    result = fs.appendFileSync(file, content, options);
                    // set the flag to append as this is the append request
                    return [4 /*yield*/, updateContentMap(file, content, { flag: "a" })];
                case 1:
                    // set the flag to append as this is the append request
                    _a.sent();
                    return [2 /*return*/, result];
            }
        });
    });
}
exports._appendJsonFileSync = _appendJsonFileSync;
/**
 * Set/update a json element value
 */
function _setJsonValue(file, key, value, options) {
    if (options === void 0) { options = {}; }
    // get the json and set/update
    var jsonObj = _readJsonFileSync(file);
    if (!jsonObj) {
        jsonObj = {};
    }
    jsonObj[key] = value;
    // write the update
    _writeJsonFileSync(file, jsonObj, options);
}
exports._setJsonValue = _setJsonValue;
/**
 * Get a json element value
 * @param file
 * @param key
 */
function _getJsonValue(file, key) {
    // get the value based on the key
    var jsonObj = _readJsonFileSync(file);
    if (!jsonObj) {
        return null;
    }
    return jsonObj[key];
}
exports._getJsonValue = _getJsonValue;
function _readJsonArraySync(file) {
    // get the value based on the key
    var jsonObj = _readJsonFileSync(file);
    if (jsonObj) {
        if (Array.isArray(jsonObj)) {
            return jsonObj;
        }
        else {
            return [jsonObj];
        }
    }
    return [];
}
exports._readJsonArraySync = _readJsonArraySync;
/**
 * Return a JSON array from a file containing lines of JSON
 * @param file
 */
function _readJsonLinesSync(file) {
    var jsonArray = [];
    if (fs.existsSync(file)) {
        var content = _readContentFileSync(file);
        if (content) {
            try {
                jsonArray = content
                    .split(/\r?\n/)
                    // parse each line to JSON
                    .map(function (item) {
                    if (item) {
                        return JSON.parse(item);
                    }
                    return null;
                })
                    // make sure we don't return any null lines
                    .filter(function (item) { return item; });
            }
            catch (err) {
                err.message = file + ": " + err.message;
                throw err;
            }
        }
    }
    return jsonArray;
}
exports._readJsonLinesSync = _readJsonLinesSync;
/**
 *
 * @param file
 * @param attribute
 * @param direction desc by default
 */
function _findSortedJsonElement(file, attribute, direction) {
    if (direction === void 0) { direction = "asc"; }
    var jsonArray = _readJsonArraySync(file);
    if (jsonArray && jsonArray.length) {
        if (direction.toLowerCase() === "desc") {
            // desc
            if (attribute) {
                jsonArray.sort(function (a, b) { return a[attribute] - b[attribute]; });
            }
            else {
                jsonArray.sort(function (a, b) { return a - b; });
            }
        }
        else {
            // asc
            if (attribute) {
                jsonArray.sort(function (a, b) { return b[attribute] - a[attribute]; });
            }
            else {
                jsonArray.sort(function (a, b) { return b - a; });
            }
        }
        return jsonArray[0];
    }
    return null;
}
exports._findSortedJsonElement = _findSortedJsonElement;
function updateContentMap(file, content, options) {
    return __awaiter(this, void 0, void 0, function () {
        return __generator(this, function (_a) {
            switch (_a.label) {
                case 0:
                    if (!(options.flag && options.flag === "a")) return [3 /*break*/, 2];
                    return [4 /*yield*/, _readContentFileAsync(file).then(function (result) {
                            contentMap[file] = result;
                        })];
                case 1:
                    _a.sent();
                    return [3 /*break*/, 3];
                case 2:
                    // overwrite what we have
                    contentMap[file] = content;
                    _a.label = 3;
                case 3: return [2 /*return*/];
            }
        });
    });
}
function getFileType(fileName) {
    var fileType = "";
    var lastDotIdx = fileName.lastIndexOf(".");
    var len = fileName.length;
    if (lastDotIdx !== -1 && lastDotIdx < len - 1) {
        fileType = fileName.substring(lastDotIdx + 1);
    }
    return fileType || "";
}
function isJsonFileType(fileName) {
    var fileType = getFileType(fileName);
    if (fileType.toLowerCase() === "json") {
        return true;
    }
    return false;
}
