'use strict';
Object.defineProperty(exports, "__esModule", { value: true });
var tokenizer_1 = require("./tokenizer");
exports.tokenizer = tokenizer_1.default;
var IMPORT_PATH_SEPARATOR_RE = /,\s*/;
var IMPORT_PATH_RE = /['"](.*)['"]/;
var DYNAMIC_IMPORT_RE = /\/\/|[#{}\*]/;
var CSS_IMPORT_RE = /\.css$/;
var PARAMETER_SEPARATOR_RE = /([,;]\s*)(?=\$)/;
var PARAMETER_RE = /([\n\t\r\s]*)(\$[\w-]+)(?:\s*:\s*(.*))?/;
function makeMixinParameters(text, offset) {
    var variables = [];
    if (!text || text === '()') {
        return variables;
    }
    // Remove parenthesis
    text = text.slice(1, text.length - 1);
    var params = text.split(PARAMETER_SEPARATOR_RE);
    // Skip `(`
    offset += 1;
    for (var i = 0; i < params.length; i = i + 2) {
        var token = params[i];
        var match = token.match(PARAMETER_RE);
        offset += match[1].length || 0;
        variables.push({
            name: match[2],
            value: match[3] ? match[3].trim() : null,
            offset: offset
        });
        offset += token.trim().length + (params[i + 1] ? params[i + 1].length : 0);
    }
    return variables;
}
function skipRulesets(tokens, token, pos) {
    var ruleset = 1;
    while (pos < tokens.length) {
        token = tokens[pos];
        if (ruleset === 0) {
            break;
        }
        else if (token[0] === '{') {
            ruleset++;
        }
        else if (token[0] === '}') {
            ruleset--;
        }
        pos++;
    }
    return {
        token: token,
        pos: pos
    };
}
function parseSymbols(text) {
    var tokens = tokenizer_1.default(text);
    var variables = [];
    var mixins = [];
    var functions = [];
    var imports = [];
    var token;
    var nextToken;
    var pos = 0;
    var offset = 0;
    var length = tokens.length;
    while (pos < length) {
        token = tokens[pos];
        if (token[0] === 'at-word' && token[1] === '@import') { // Import's
            pos++;
            var str = '';
            while (pos < length) {
                token = tokens[pos];
                if (token[0] === ';') {
                    break;
                }
                str += token[1];
                pos++;
            }
            str.split(IMPORT_PATH_SEPARATOR_RE).forEach(function (x) {
                var match = x.match(IMPORT_PATH_RE);
                if (!match) {
                    return;
                }
                imports.push({
                    filepath: match[1],
                    dynamic: DYNAMIC_IMPORT_RE.test(match[1]),
                    css: CSS_IMPORT_RE.test(match[1])
                });
            });
        }
        else if (token[0] === 'at-word') { // Mixins or Functions
            if (token[1] !== '@mixin' && token[1] !== '@function') {
                pos++;
                while (pos < length) {
                    token = tokens[pos];
                    nextToken = tokens[pos + 1] || [];
                    if (token[0] === '{') {
                        break;
                    }
                    else if (token[0] === ')' && nextToken[0] === ';') {
                        pos++;
                        break;
                    }
                    pos++;
                }
                continue;
            }
            var entity = token[1] === '@mixin' ? mixins : functions;
            offset = token[2];
            pos++;
            var name_1 = '';
            while (pos < length) {
                token = tokens[pos];
                if (token[0] === 'brackets' || token[0] === '(' || token[0] === '{') {
                    break;
                }
                name_1 += token[1];
                pos++;
            }
            var paramsOffset = offset;
            var params = '';
            if (token[0] === 'brackets') {
                paramsOffset = token[2];
                params = token[1];
            }
            else if (token[0] === '(') {
                paramsOffset = token[2];
                pos++;
                while (pos < length) {
                    token = tokens[pos];
                    if (token[0] === ')') {
                        break;
                    }
                    params += token[1];
                    pos++;
                }
                params = "(" + params + ")";
            }
            if (token[0] === '{') {
                var info = skipRulesets(tokens, token, ++pos);
                token = info.token;
                pos = info.pos;
            }
            if (name_1) {
                entity.push({
                    name: name_1.trim(),
                    parameters: makeMixinParameters(params, paramsOffset),
                    offset: offset
                });
            }
            else {
                pos--;
            }
        }
        else if (token[0] === 'word' && token[1].startsWith('$')) { // Variables
            offset = token[2];
            pos++;
            var name_2 = token[1];
            var value = '';
            while (pos < length) {
                token = tokens[pos];
                if (token[0] === ';') {
                    break;
                }
                else if (token[0] === 'word' || token[0] === 'at-word' || token[0] === 'string' || token[0] === 'space' || token[0] === 'brackets') {
                    value += token[1];
                }
                pos++;
            }
            if (pos === length && token[0] !== ';') {
                continue;
            }
            variables.push({
                name: name_2,
                value: value.trim(),
                offset: offset
            });
        }
        else if (token[0] === '{') { // Ruleset
            var info = skipRulesets(tokens, token, ++pos);
            token = info.token;
            pos = info.pos;
        }
        pos++;
    }
    return {
        variables: variables,
        mixins: mixins,
        functions: functions,
        imports: imports
    };
}
exports.parseSymbols = parseSymbols;
